



















<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RPG Battle Arena</title>

<!-- Google Font -->
<link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
<style>
/* === Reset & Body === */
* { margin:0; padding:0; box-sizing:border-box; }

html, body {
  height: 100%;
  width: 100%;
  overflow-x: hidden;
  font-family: 'Share Tech Mono', monospace;
  color: #fff;
  background: url('https://raw.githubusercontent.com/zaddiii/RPG-Battle-Arena/71c5d6084edf814937ae42963d74c3c3319358b7/James%20Paick%20-%20Jamespaickart%20-%202017-09-20_15-00-51_Utc.jpeg') 
    no-repeat center center fixed;
  background-size: cover;
  background-attachment: fixed;
}

/* Overlay for dark vibe */
body::before {
  content: '';
  position: fixed;
  top:0; left:0;
  width:100%; height:100%;
  background: rgba(0,0,0,0.65);
  z-index: -1;
}

/* Title */
h1 {
  text-align: center;
  font-size: clamp(1.8rem, 4vw, 2.5rem);
  color: #0ff;
  text-shadow: 0 0 10px #0ff, 0 0 20px #00f;
  margin: 2vh 0;
}

/* Scoreboard (transparent) */
#scoreboard {
  position: fixed;
  top: 1.5vh;
  left: 1.5vw;
  background: rgba(0,0,0,0.25);
  padding: 1vh 1.5vw;
  border-radius: 12px;
  font-size: clamp(11px, 1.6vw, 14px);
  line-height: 1.4;
  text-align: left;
  box-shadow: 0 0 10px #0ff;
  z-index: 10;
}

/* Game Area */
#gameArea {
  width: min(90vw, 650px);
  margin: 10vh auto 4vh auto;
  padding: 2vw;
  background: rgba(0,0,30,0.9);
  border-radius: 20px;
  box-shadow: 0 0 20px #0ff inset;
}

/* Bars */
.bar-container {
  position: relative;
  background: #111;
  border-radius: 12px;
  height: clamp(18px, 2.5vh, 22px);
  margin-bottom: 12px;
  overflow: hidden;
  border: 2px solid #222;
}
.bar {
  height: 100%;
  transition: width 0.5s ease, background 0.5s ease;
}
#playerHealthBar { background: linear-gradient(90deg, #f00, #900); }
#playerManaBar { background: linear-gradient(90deg, #00f, #006); }
#enemyHealthBar { background: linear-gradient(90deg, #f00, #900); }
#enemyManaBar { background: linear-gradient(90deg, #00f, #006); }
#enemyIntelligenceBar { background: linear-gradient(90deg, #0f0, #060); }

.bar-text {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: #fff;
  font-size: clamp(11px, 1.6vw, 13px);
  font-weight: bold;
  text-shadow: 0 0 5px #000;
  pointer-events: none;
}

/* Buttons */
button {
  padding: clamp(10px, 1.5vh, 14px) clamp(18px, 2vw, 26px);
  margin: 6px;
  border-radius: 12px;
  border: none;
  background: linear-gradient(to bottom, #0ff, #008888);
  color: #000;
  font-weight: bold;
  font-size: clamp(12px, 2vw, 16px);
  cursor: pointer;
  box-shadow: 0 0 15px #0ff;
  transition: 0.15s;
}
button:hover {
  background: linear-gradient(to bottom, #00d4ff, #0ff);
  transform: scale(1.08);
  box-shadow: 0 0 25px #0ff, 0 0 35px #00ffff;
}
button:active {
  transform: scale(0.97);
  box-shadow: 0 0 10px #0ff;
}

/* Battle Log */
#battleLog {
  background: rgba(0,0,0,0.7);
  padding: 12px;
  border-radius: 12px;
  height: clamp(120px, 18vh, 160px);
  overflow-y: auto;
  font-size: clamp(11px, 1.6vw, 13px);
  margin-top: 15px;
  text-align: left;
}
#battleLog p {
  margin-bottom: 6px;
  opacity: 0;
  animation: fadeIn 0.4s forwards;
}
@keyframes fadeIn {
  to { opacity:1; }
}

/* Navigation Menu */
#navMenu {
  position: fixed;
  bottom: 2vh;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 10px;
  z-index: 10;
}
#navMenu button {
  font-size: clamp(11px, 2vw, 13px);
  padding: 10px 18px;
  border-radius: 50px;
}

/* Alert Box */
#alertBox {
  position: fixed;
  top: 6vh;
  left: 50%;
  transform: translateX(-50%);
  padding: 10px 20px;
  background: rgba(0,0,0,0.8);
  border: 2px solid #0ff;
  border-radius: 10px;
  font-weight: bold;
  color: #0ff;
  opacity: 0;
  transition: opacity 0.3s ease;
  font-size: clamp(12px, 1.8vw, 14px);
}
#alertBox.show { opacity: 1; }

/* Responsive Scaling */
@media (max-width: 600px) {
  h1 { font-size: clamp(1.5rem, 5vw, 2.2rem); }
  #gameArea { margin: 8vh auto; padding: 4vw; }
  button { font-size: clamp(11px, 3vw, 14px); }
  #battleLog { height: 130px; }
}
</style>
</head>
<body>

<h1>RPG Battle Arena ‚öî</h1>

<div id="scoreboard">
  <p><strong>Player Wins:</strong> <span id="playerWins">0</span></p>
  <p><strong>Enemy Wins:</strong> <span id="enemyWins">0</span></p>
  <p><strong>Score:</strong> <span id="score">0</span></p>
  <p><strong>AI IQ:</strong> <span id="aiIQ">0</span></p>
  <p><strong>üí∞ Tokens:</strong> <span id="walletBalance">0</span></p>
</div>

<div id="gameArea">
  <p><strong>üßë‚ÄçüéÆ Player</strong></p>
  <div class="bar-container"><div id="playerHealthBar" class="bar" style="width:100%;"></div><span id="playerHealthText" class="bar-text">200 / 200</span></div>
  <div class="bar-container"><div id="playerManaBar" class="bar" style="width:100%;"></div><span id="playerManaText" class="bar-text">50 / 50</span></div>

  <p style="margin-top:12px;"><strong>üëæ Enemy</strong></p>
  <div class="bar-container"><div id="enemyHealthBar" class="bar" style="width:100%;"></div><span id="enemyHealthText" class="bar-text">200 / 200</span></div>
  <div class="bar-container"><div id="enemyManaBar" class="bar" style="width:100%;"></div><span id="enemyManaText" class="bar-text">50 / 50</span></div>
  <div class="bar-container"><div id="enemyIntelligenceBar" class="bar" style="width:0;"></div><span id="enemyIntelligenceText" class="bar-text">IQ 0</span></div>

  <div style="margin-top:15px;">
    <button onclick="playerAction('Attack')">Attack</button>
    <button onclick="playerAction('Defend')">Defend</button>
    <button onclick="playerAction('Special')">Special (-30 MP)</button>
    <button onclick="playerAction('Heal')">Heal (+20 HP, -20 MP)</button>
    <button onclick="resetGame()">Reset</button>
  </div>

  <div id="battleLog"></div>
</div>

<div id="alertBox"></div>

<div id="navMenu">
  <button onclick="location.href='upgrade.html'">üõ† Upgrade</button>
  <button onclick="window.open('rpgFlip.html','_blank','width=500,height=700')">üé≤ Flip Coin</button>
</div>

<script>
/* === Load Upgrades (keeps existing behavior) === */
let attackUpgrade = parseInt(localStorage.getItem('attackUpgrade')) || 0;
let specialUpgrade = parseInt(localStorage.getItem('specialUpgrade')) || 0;
function loadUpgrades() {
  attackUpgrade = parseInt(localStorage.getItem('attackUpgrade')) || 0;
  specialUpgrade = parseInt(localStorage.getItem('specialUpgrade')) || 0;
}

// Live Upgrade Updates
function applyUpgrades() {
  // Read current upgrades from localStorage
  attackUpgrade = parseInt(localStorage.getItem('attackUpgrade')) || 0;
  specialUpgrade = parseInt(localStorage.getItem('specialUpgrade')) || 0;

  // Optional: show upgrade info on screen (if you have UI for it)
  const attackInfo = document.getElementById('attackUpgradeInfo');
  const specialInfo = document.getElementById('specialUpgradeInfo');
  if(attackInfo) attackInfo.innerText = `Attack Upgrade: +${attackUpgrade}%`;
  if(specialInfo) specialInfo.innerText = `Special Upgrade: x${Math.pow(2, specialUpgrade)}`;
}

// Watch for changes in localStorage from upgrade page
window.addEventListener('storage', (event) => {
  if(event.key === 'attackUpgrade' || event.key === 'specialUpgrade') {
    applyUpgrades();
    showAlert('Upgrades Updated!');
  }
});

// Initial load on game start
applyUpgrades();

/* === Constants & base stats === */
const PLAYER_MAX_HP = 200;
const PLAYER_BASE_MP = 50;
const MAX_MP = PLAYER_BASE_MP;
const SPECIAL_COST = 30;
const HEAL_COST = 20;
const HEAL_HP = 20;

/* === State === */
let scores = { player: 0, enemy: 0, score: 0 };
let playerHP = PLAYER_MAX_HP, playerMP = PLAYER_BASE_MP;
let enemyMaxHP = 200, enemyMaxMP = 50; // base as you specified
let enemyHP = enemyMaxHP, enemyMP = enemyMaxMP;
let enemyIQ = 0;
let enemyDefending = false, playerDefending = false;

let aiInterval = null, aiActive = false, regenInterval = null, roundOver = false;

/* === Wallet (localStorage) === */
let wallet = { tokens: 0 };
function loadWallet(){
  const saved = localStorage.getItem("rpgWallet");
  if(saved) wallet = JSON.parse(saved);
  else { wallet.tokens = 1000; saveWallet(); showAlert('Welcome! 1000 tokens granted.'); }
  updateScoreboard();
}
function saveWallet(){
  localStorage.setItem("rpgWallet", JSON.stringify(wallet));
  updateScoreboard();
}

/* === Small utilities === */
const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
const randInt = (a,b) => Math.floor(Math.random()*(b-a+1)) + a;
const log = t => { const p = document.createElement("p"); p.innerText = t; battleLog.appendChild(p); battleLog.scrollTop = battleLog.scrollHeight; };
function showAlert(msg){ const box = document.getElementById("alertBox"); box.textContent = msg; box.classList.add("show"); setTimeout(()=>box.classList.remove("show"),1500); }

/* === Bars & scoreboard updates (keeps your DOM IDs) === */
function updateBars(){
  // Avoid division by zero
  const pMax = PLAYER_MAX_HP || 200;
  playerHealthBar.style.width = (playerHP / pMax * 100) + '%';
  playerManaBar.style.width = (playerMP / MAX_MP * 100) + '%';
  enemyHealthBar.style.width = (enemyHP / enemyMaxHP * 100) + '%';
  enemyManaBar.style.width = (enemyMP / enemyMaxMP * 100) + '%';
  playerHealthText.innerText = `${playerHP}/${PLAYER_MAX_HP}`;
  playerManaText.innerText = `${playerMP}/${MAX_MP}`;
  enemyHealthText.innerText = `${enemyHP}/${enemyMaxHP}`;
  enemyManaText.innerText = `${enemyMP}/${enemyMaxMP}`;
  enemyIntelligenceBar.style.width = (enemyIQ > 100 ? 100 : enemyIQ) + '%';
  enemyIntelligenceText.innerText = `IQ ${enemyIQ.toFixed(1)}`;
}
function updateScoreboard(){
  playerWins.innerText = scores.player;
  enemyWins.innerText = scores.enemy;
  score.innerText = scores.score;
  aiIQ.innerText = enemyIQ.toFixed(1);
  document.getElementById("walletBalance").innerText = wallet.tokens;
}

/* === Enemy scaling function (persistent scaling) ===
   On every player win:
     - enemyIQ += 1.5
     - enemyMaxHP += 100
     - enemyMaxMP += 20
   Current HP/MP are set to full when scaled.
*/
function increaseEnemyStatsPerWin() {
  enemyIQ = +(enemyIQ + 1.5).toFixed(1);
  enemyMaxHP = enemyMaxHP + 100;
  enemyMaxMP = enemyMaxMP + 20;
  // top up to new max so next round starts full
  enemyHP = enemyMaxHP;
  enemyMP = enemyMaxMP;
  updateBars();
}

/* === Player actions === */
function playerAction(act){
  if(roundOver) return;
  if(!aiActive){ aiActive = true; startAI(); log("AI engages after your first move!"); }
  playerDefending = false;

  if(act === 'Attack'){
    // attackUpgrade is percent stored (e.g., 30 means +30%)
    const base = randInt(12, 28);
    const dmg = Math.floor(base * (1 + (attackUpgrade||0)/100));
    const actual = enemyDefending ? Math.floor(dmg * 0.25) : dmg;
    enemyHP = clamp(enemyHP - actual, 0, enemyMaxHP);
    showAlert(`You attacked for ${actual}!`);
    log(`Player attacks ‚Üí ${actual} dmg.`);
  }
  else if(act === 'Defend'){
    playerDefending = true;
    showAlert("You defend!");
    log("Player defends (reduced dmg next enemy hit).");
  }
  else if(act === 'Special'){
    if(playerMP < SPECIAL_COST){ showAlert('Not enough mana.'); return; }
    playerMP -= SPECIAL_COST;
    const base = randInt(30, 50);
    const dmg = Math.floor(base * Math.pow(2, specialUpgrade || 0));
    const actual = enemyDefending ? Math.floor(dmg * 0.25) : dmg;
    enemyHP = clamp(enemyHP - actual, 0, enemyMaxHP);
    showAlert(`You used Special ‚Üí ${actual}!`);
    log(`Player Special ‚Üí ${actual} dmg.`);
  }
  else if(act === 'Heal'){
    if(playerHP >= PLAYER_MAX_HP){ showAlert('HP full.'); return; }
    if(playerMP < HEAL_COST){ showAlert('Not enough mana.'); return; }
    const heal = Math.min(HEAL_HP, PLAYER_MAX_HP - playerHP);
    playerMP -= HEAL_COST;
    playerHP = clamp(playerHP + heal, 0, PLAYER_MAX_HP);
    showAlert(`Healed +${heal} HP (-${HEAL_COST} MP).`);
    log(`Player heals +${heal} HP.`);
  }

  updateBars();
  checkEnd();
}

/* === Enemy AI === */
function decideAction(){
  // Weighted random: Attack (50%), Defend (15%), Heal (20%), Special (15%)
  const r = Math.random();
  if(r < 0.5) return 'Attack';
  if(r < 0.65) return 'Defend';
  if(r < 0.85) return 'Heal';
  return 'Special';
}
function enemyAction(){
  if(!aiActive || playerHP <= 0 || enemyHP <= 0 || roundOver) return;
  enemyDefending = false;
  const act = decideAction();

  if(act === 'Attack'){
    let dmg = randInt(18, 35);
    let actual = playerDefending ? Math.floor(dmg * 0.25) : dmg;
    playerHP = clamp(playerHP - actual, 0, PLAYER_MAX_HP);
    showAlert(`Enemy attacks ${actual}!`);
    log(`Enemy attacks ‚Üí ${actual} dmg.`);
  }
  else if(act === 'Defend'){
    enemyDefending = true;
    showAlert("Enemy defends!");
    log("Enemy defends (reduced dmg next player hit).");
  }
  else if(act === 'Special' && enemyMP >= SPECIAL_COST){
    enemyMP -= SPECIAL_COST;
    let dmg = randInt(30, 50);
    let actual = playerDefending ? Math.floor(dmg * 0.25) : dmg;
    playerHP = clamp(playerHP - actual, 0, PLAYER_MAX_HP);
    showAlert(`Enemy Special ‚Üí ${actual}!`);
    log(`Enemy Special ‚Üí ${actual} dmg.`);
  }
  else if(act === 'Heal' && enemyMP >= HEAL_COST && enemyHP < enemyMaxHP){
    const heal = Math.min(HEAL_HP, enemyMaxHP - enemyHP);
    enemyMP -= HEAL_COST;
    enemyHP = clamp(enemyHP + heal, 0, enemyMaxHP);
    showAlert(`Enemy heals +${heal} HP.`);
    log(`Enemy heals +${heal} HP.`);
  }

  updateBars();
  checkEnd();
}

/* === Intervals === */
function startAI(){ clearInterval(aiInterval); aiInterval = setInterval(enemyAction, 600); }
function startRegen(){ clearInterval(regenInterval); regenInterval = setInterval(()=>{
  playerMP = clamp(playerMP + 2, 0, MAX_MP);
  enemyMP = clamp(enemyMP + 2, 0, enemyMaxMP);
  updateBars();
}, 1000); }

/* === Check end of round & apply rewards/penalties === */
function checkEnd(){
  if(roundOver) return;
  if(playerHP <= 0 || enemyHP <= 0){
    roundOver = true;
    clearInterval(aiInterval); clearInterval(regenInterval); aiActive = false;

    if(enemyHP <= 0 && playerHP <= 0){
      showAlert('Double KO!');
      log('Double KO ‚Äî no changes.');
    }
    else if(enemyHP <= 0){
      // Player win
      showAlert('You Win!');
      scores.player++; scores.score += 50;
      // Random-ish token reward: 100..150
      const reward = 100 + randInt(0, 50);
      wallet.tokens += reward;
      saveWallet();

      // Increase enemy stats (persistent)
      increaseEnemyStatsPerWin();

      log(`üèÜ You earned ${reward} tokens! Wallet: ${wallet.tokens} | Enemy IQ ${enemyIQ.toFixed(1)}, HP ‚Üí ${enemyMaxHP}, MP ‚Üí ${enemyMaxMP}`);
    }
    else {
      // Enemy win
      showAlert('You Lose!');
      scores.enemy++;
      scores.score = Math.max(0, scores.score - 30);
      log('You lost this round.');
    }

    updateScoreboard();
    // new round after short delay
    setTimeout(()=>{ roundOver = false; newRound(); }, 1200);
  }
}

/* === New round / reset round (not entire reset) === */
function newRound(){
  playerHP = PLAYER_MAX_HP; playerMP = MAX_MP;
  // enemy keeps scaled max HP/MP (persistent). Start round full.
  enemyHP = enemyMaxHP; enemyMP = enemyMaxMP;

  enemyDefending = playerDefending = false;
  aiActive = false;
  updateBars(); updateScoreboard();
  log('New round ‚Äî AI waits for your move.');
  startRegen();
}

/* === Full reset (reset scores, wallet kept if you want, but here we restore tokens) === */
function resetGame(){
  scores = { player: 0, enemy: 0, score: 0 };
  wallet.tokens = 1000;
  // Reset enemy scaling to base values if you want a full reset:
  enemyIQ = 0;
  enemyMaxHP = 200;
  enemyMaxMP = 50;
  enemyHP = enemyMaxHP;
  enemyMP = enemyMaxMP;

  saveWallet();
  newRound();
  updateScoreboard();
  log('Game reset ‚Äî Wallet restored to 1000 tokens and Enemy stats reset.');
}

/* === Start helper (keeps original startGame function available) === */
function startGame(){
  // If your UI toggles gameArea etc, keep behavior consistent with original
  const gameArea = document.getElementById('gameArea');
  const startBtn = document.getElementById('startBtn');
  if(gameArea) gameArea.style.display = "block";
  if(startBtn) startBtn.style.display = "none";
  newRound();
  showAlert("Welcome to the Arena ‚öî!");
  log("Game started. You move first!");
  loadWallet();
  loadUpgrades();
}

/* === Initialize on load === */
window.addEventListener("DOMContentLoaded", () => {
  updateBars();
  updateScoreboard();
  // startRegen optional - we can start regen once UI starts a round
});
</script>
</body>
</html>